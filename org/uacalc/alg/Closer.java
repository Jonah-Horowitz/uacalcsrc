package org.uacalc.alg;

import java.util.*;
import java.util.logging.*;
import java.util.concurrent.*;
import java.math.BigInteger;

import org.uacalc.ui.tm.ProgressReport;
import org.uacalc.util.*;
import org.uacalc.terms.*;
import org.uacalc.eq.*;
import org.uacalc.io.TermMapWriter;
import org.uacalc.alg.conlat.*;
import org.uacalc.alg.op.AbstractOperation;
import org.uacalc.alg.op.Operation;
import org.uacalc.alg.op.OperationWithDefaultValue;
import org.uacalc.alg.op.OperationSymbol;
import org.uacalc.alg.op.Operations;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

import org.uacalc.util.SequenceIterator;
import java.io.FileNotFoundException;


/**
 * A class for finding the closure with configurations for several options
 * and fields to hold side results.
 * It only deals with BigProduct's now. We might call it BigProductCloser
 * and have Closer as an interface.
 * 
 * 
 * @author ralph
 *
 */
public class Closer {
	
	public static final int FEEDER_CAPACITY = 10000; // The capacity for a parallel "feeder" queue
	public static final int PROCESS_PER_LOOP = 1000; // The number of chunks to process per main loop in the controller Thread
  
  BigProductAlgebra algebra;
  List<IntArray> ans;
  boolean completed = false; // sometimes we end early
  List<IntArray> generators;
  Map<IntArray,Term> termMap; // initially a map from generators to variables.
  // this is double used: it is set in the closing if we are looking
  // for a pattern but set before is it an element we are looking for.
  // probably should have separate fields for these two things.
  IntArray eltToFind;
  List<IntArray> eltsToFind;  // find all
  Map<IntArray,Integer> indecesMapOfFoundElts;
  boolean allEltsFound = false;
  int specialEltsFound = 0;
  final static Integer minusOne = new Integer(-1);
  SmallAlgebra imageAlgebra;
  Map<IntArray,Integer> homomorphism; // actually a partial homo into imageAlg.
  Equation failingEquation = null; // a list of two terms
  SmallAlgebra rootAlgebra; // the root of a power algebra
  // a list of operations on the set of the root algebra; to test if they are in the clone. 
  List<Operation> operations;
  Map<Operation,Term> termMapForOperations;
  // a blocks and values constraint as in IntArray.
  int[][] blocks;
  int[][] values;
  // stop closing  if we have found this many elements. 
  // only used in sgClosePower for now.
  // ned to amke a UI for this.
  int maxSize = -1; //380; //-1;
  
  ProgressReport report;
  private boolean suppressOutput;
  public String writeTermMapOnComplete=null;
  
  static final int nCPUs = Runtime.getRuntime().availableProcessors(); 
  
  public Closer(BigProductAlgebra alg, List<IntArray> gens) {
    this.algebra = alg;
    setGenerators(gens);  // this will remove duplicates
  }
  
  public Closer(BigProductAlgebra alg, List<IntArray> gens, Map<IntArray,Term> termMap) {
    this(alg, gens);
    this.termMap = termMap;
  }
  
  public Closer(BigProductAlgebra alg, List<IntArray> gens, boolean makeTermMap) {
    this(alg, gens);
    if (makeTermMap) setupTermMap();
  }
  
  private void setupTermMap() {
    termMap = new HashMap<IntArray,Term>();
    if (generators.size() == 1) termMap.put(generators.get(0), Variable.x);
    if (generators.size() == 2) {
      termMap.put(generators.get(0), Variable.x);
      termMap.put(generators.get(1), Variable.y);
    }
    if (generators.size() == 3) {
      termMap.put(generators.get(0), Variable.x);
      termMap.put(generators.get(1), Variable.y);
      termMap.put(generators.get(2), Variable.z);
    }
    int k = 0;
    if (generators.size() > 3) {
      for (Iterator<IntArray> it = generators.iterator(); it.hasNext(); k++) {
        Variable var = new VariableImp("x_" + k);
        termMap.put(it.next(), var);
      }
    }
  }
  
  public List<IntArray> getAnswer() { return ans; }
  
  public Equation getFailingEquation() { return failingEquation; }
  
  // stuff for finding a terms of given operations
  public Map<Operation,Term> getTermMapForOperations() { return termMapForOperations; }
  
  /**
   * Sets the root of a power algebra, if the closing computes a subpower.
   * 
   * If the underlying <code>BigProductAlgebra</code> is a power, then this method
   * can be used to set the field of the closer referencing the root underlying
   * the power.
   * 
   * @param alg a <code>SmallAlgebra</code> such that its power is the <code>BigProductAlgebra</code>
   *            determining the closure to be generated by the <code>Closer</code>.
   */
  public void setRootAlgebra(SmallAlgebra alg) { rootAlgebra = alg; }
  
  public void setOperations(List<Operation> opers) { operations = opers; }
  
  /**
   * Returns a shallow copy of the list of generators used by <code>this Closer</code>
   * to generate a subuniverse.
   * 
   * The returned list is part of the <code>Closer</code> object, so any modification
   * applied to it modifies the <code>Closer</code>.
   *
   * @return a <code>List</code> of <code>IntArray</code>s representing the generating
   *         set whose closure is to be computed
   */
  public List<IntArray> getGenerators() { return generators; }
  
  /**
   * This sets <code>generators</code> to <code>gens</code> without any duplicates.
   *
   * Initializes the internal field of the <code>Closer</code> to contain the generators
   * from <code>gens</code> in the order they occur there, ignoring possible repetitions
   * of tuples in <code>gens</code>.
   *
   * @param gens a <code>List</code> of tuples (<code>IntArray</code>s) from which 
   *             a subuniverse should be generated
   */
  public void setGenerators(List<IntArray> gens) {
    generators = new ArrayList<IntArray>(gens.size());
    final Set<IntArray> hs = new HashSet<IntArray>(gens.size());
    for (IntArray ia : gens) {
      if (hs.add(ia)) {
        generators.add(ia);
      }
    }
  }
  
  /**
   * Returns a <code>Map</code> assigning to each tuple in the generated subuniverse a 
   * term over the signature of the underlying algebra whose term operation can be
   * applied to the generators to obtain the tuple.
   * 
   * Initially this is only a map, mapping generators to variables. After the closing
   * it is a map between the elements of the generated subuniverse and the generating
   * terms.
   * <p>
   * Only a shallow copy is returned, that is, the returned <code>Map</code> is part of the 
   * <code>Closer</code>.
   *
   * @return a <code>Map</code> mapping <code>IntArray</code>s to <code>Term</code>s
   */
  public Map<IntArray,Term> getTermMap() { return termMap; }
  
  /**
   * Initialises the <code>Map</code> that will be used to assign to each tuple in the
   * generated subuniverse a term over the signature of the underlying algebra whose
   * term operation can be applied to the generators to obtain the tuple.
   * 
   * Only a shallow copy of the external <code>Map</code> is made, that is the <code>Map</code>
   * becomes part of the <code>Closer</code>.
   *
   * @param termMap a <code>Map</code> mapping <code>IntArray</code>s to <code>Term</code>s,
   *                it should map the generators to variables, to be reasonable, or it should 
   *                be <code>null</code>.
   */
  public void setTermMap(Map<IntArray,Term> termMap) {
    this.termMap = termMap;
  }
  
  public SmallAlgebra getImageAlgebra() { return imageAlgebra; }
  
  public void setImageAlgebra(SmallAlgebra alg) {
    if (!alg.similarityType().equals(algebra.similarityType())) {
      throw new IllegalArgumentException("the algebras must be similar");
    }
    imageAlgebra = alg;
  }
  
  // TODO add convenience methods to build these maps.
  public Map<IntArray,Integer> getHomomorphism() { return homomorphism; }
  
  public void setHomomorphism(Map<IntArray,Integer> homomorphism) {
    this.homomorphism = homomorphism;
  }
  
  public void setHomomorphism(int[] algGens) {
    if (algGens.length != generators.size()) {
      throw new IllegalArgumentException("wrong number of generators");
    }
    Map<IntArray,Integer> homo = new HashMap<IntArray,Integer>(generators.size());
    int k = 0;
    for (IntArray g : generators) {
      homo.put(g, algGens[k++]);
    }
    this.homomorphism = homo;
  }
  
  public IntArray getElementToFind() { return eltToFind; }
  
  public void setElementToFind(IntArray e) { eltToFind = e; }
  
  public List<IntArray> getElementsToFind() { return eltsToFind; }
  
  public void setElementsToFind(List<IntArray> e, List<IntArray> gens) {
    eltsToFind = e;
    indecesMapOfFoundElts = new HashMap<IntArray,Integer>(e.size());
    for (IntArray ia : e) {
      indecesMapOfFoundElts.put(ia, minusOne);
    }
    for (int i = 0; i < gens.size(); i++) {
      if (minusOne.equals(indecesMapOfFoundElts.get(gens.get(i)))) {
        indecesMapOfFoundElts.put(gens.get(i), i);
        specialEltsFound++;
      }
    }
  }
  
  public boolean allElementsFound() { return allEltsFound; }
  
  public int[][] getBlocks() { return blocks; }
  
  public void setBlocks(int[][] blocks) { this.blocks = blocks; }
  
  public int[][] getValues() { return values; }
  
  public void setValues(int[][] values) { this.values = values; }
  
  public int getmaxSize() { return maxSize; }
  
  public void setMaxSize(int k) { maxSize = k; }
  
  //protected static ProgressReport monitor;
  
  /*
  public boolean monitoring() {
    return monitor != null;
  }
  
  public static final void setMonitor(ProgressReport m) { monitor = m; }
  public static final ProgressReport getMonitor() { return monitor; }
  */
  
  public void setProgressReport(ProgressReport report) {
    this.report = report;
  }
  
  public List<IntArray> close() {
    // TODO fix this
    if (!algebra.isPower()) {
      throw new IllegalArgumentException("only implemented for powers");
    }
    ans = new ArrayList<IntArray>(generators);
    return ans;
  }
  
  public List<IntArray> sgClose() {
    //System.out.println("nCPU = " + nCPUs);
    //System.out.println("termMap = " + termMap);
    //return sgCloseParallel(generators, 0, termMap);
    return sgClose(generators, 0, termMap);
  }
  
  /**
   * Closure of <tt>elems</tt> under the operations. (Worry about
   * nullary ops later.)
   *
   * @param elems a List of IntArray's
   *
   * @param termMap a Map from the element to the corresponding term
   *                used to generated it. The generators should be 
   *                already in the Map. In other words the termMap
   *                should have the same number of entries as elems.
   *
   * @return a List of IntArray's.
   */
  public List<IntArray> sgClose(List<IntArray> elems, int closedMark, 
                                     final Map<IntArray,Term> termMap) {
    if (algebra.isPower()) {
      SmallAlgebra alg = algebra.rootFactors().get(0);
      alg.makeOperationTables();
      return sgClosePower(elems, closedMark, termMap);
      //List<Operation> ops = alg.operations();
      //if (ops.size() > 0 && ops.get(0).getTable() != null) {
        //return sgClosePower(alg.cardinality(), ops, elems,
        //                                       closedMark, termMap, elt);
        // TODO restore above
      //  return null;
      //}
    }
    
    if (report != null) report.addStartLine("subpower closing ...");

    final int numOfOps = algebra.operations().size();  
    List<Operation> imgOps = null;
    if (homomorphism != null) {
      imgOps = new ArrayList<Operation>(numOfOps);
      for (Operation op : algebra.operations()) {
        imgOps.add(imageAlgebra.getOperation(op.symbol()));
      }
    }
    
    // these final boolean are meant to help the jit compiler.
    final boolean reportNotNull = report == null ? false : true;
    final boolean imgAlgNull = imgOps == null ? true : false;
    final boolean eltToFindNotNull = eltToFind == null ? false : true;
    final boolean eltsToFindNotNull = eltsToFind == null ? false : true;
    final boolean operationsNotNull = operations == null ? false : true;
    
    if (operationsNotNull) termMapForOperations = new HashMap<Operation,Term>();
    int operationsFound = 0;

    ans = new ArrayList<IntArray>(elems);// IntArrays
    final List<int[]> rawList = new ArrayList<int[]>(); // the corresponding raw int[]
    for (IntArray ia : elems) {
      rawList.add(ia.getArray());
    }
    final HashSet<IntArray> su = new HashSet<IntArray>(ans);
    //  Code to add the constants
    final List<IntArray> constants = algebra.getConstants();// add the constants, if any
    for (IntArray arr : constants) {
      if (su.add(arr)) {
        ans.add(arr);
        rawList.add(arr.getArray());
        if (termMap != null) {
          termMap.put(arr, NonVariableTerm.makeConstantTerm(algebra.constantToSymbol.get(arr)));
        }
      }
    }

    int currentMark = ans.size();
    int pass = 0;
    CloserTiming timing = null; 
    if (reportNotNull) timing = new CloserTiming(algebra, report);
    //int currPassSize = 0; // for time left
    //int lastPassSize = 0; // for time left
    //final int numberProjs = algebra.getNumberOfFactors(); // for time left
    while (closedMark < currentMark) {
      if (reportNotNull) timing.updatePass(ans.size());
      //lastPassSize = currPassSize;
      //currPassSize = ans.size();
      //long funcAppsNeeded = countFuncApplications(lastPassSize, currPassSize);
      //long appsSoFar = 0;
      String str = "pass: " + pass + ", size: " + ans.size();
      if (reportNotNull) {
        report.setPass(pass);
        report.setPassSize(ans.size());
        if (!suppressOutput) report.addLine(str);
      }
      else {
        if (!suppressOutput) System.out.println(str);
      }
      pass++;
      if (Thread.currentThread().isInterrupted()) {
        if (reportNotNull) report.addEndingLine("cancelled ...");
        return null;
      }
//if (lst.size() > 100000) return lst;
      // close the elements in current
      for (int i = 0; i < numOfOps; i++) {
      //for (Iterator<Operation> it = algebra.operations().iterator(); it.hasNext(); ) {
        //Operation f = it.next();
        Operation f = algebra.operations().get(i);
        final int arity = f.arity();
        if (arity == 0) continue;  // worry about constansts later
        int[] argIndeces = new int[arity];
        for (int j = 0; j < arity - 1; j++) {
          argIndeces[j] = 0;
        }
        argIndeces[arity - 1] = closedMark;
        ArrayIncrementor inc =
                    SequenceGenerator.sequenceIncrementor(
                                  argIndeces, currentMark - 1, closedMark);

        final int[][] arg = new int[arity][];
        while (true) {
          if (Thread.currentThread().isInterrupted()) {
            if (reportNotNull) {
              report.addEndingLine("cancelled ...");
              report.setSize(ans.size());
            }
            return null;
          }
          for (int j = 0; j < arity; j++) {
            arg[j] = rawList.get(argIndeces[j]);
          }
          
          int[] vRaw = f.valueAt(arg);
          //int[] test = f.valueAt(arg);
          IntArray v = new IntArray(vRaw);
          //IntArray testV = new IntArray(test);
           
          //System.out.println("vRaw == test is " + v.equals(new IntArray(test)));
          if (reportNotNull) timing.incrementApps();
          //appsSoFar = appsSoFar + numberProjs;
          if (su.add(v)) {
            ans.add(v);
            rawList.add(vRaw);
            if (reportNotNull) timing.incrementNextPassSize();
            if (reportNotNull) report.setSize(ans.size());
            if (Thread.currentThread().isInterrupted()) return null;
            if (termMap != null) {
              List<Term> children = new ArrayList<Term>(arity);
              for (int j = 0; j < arity; j++) {
                //children.set(i, termMap.get(arg.get(i)));
                children.add(termMap.get(ans.get(argIndeces[j])));
              }
              termMap.put(v, new NonVariableTerm(f.symbol(), children));
              //logger.fine("" + v + " from " + f.symbol() + " on " + arg);
              if (operationsNotNull) {
                Term term = termMap.get(v);
                // why are recreating vars each time ???
                List<Variable> vars = new ArrayList<Variable>(generators.size());
                for (IntArray ia : generators) {
                  vars.add((Variable)termMap.get(ia));
                }
                Operation termOp = term.interpretation(rootAlgebra, vars, true);
                for (Operation op : operations) {
                  if (termMapForOperations.containsKey(op) && Operations.equalValues(termOp, op)) {
                    termMapForOperations.put(op, term);
                    operationsFound++;
                    if (operationsFound == operations.size()) return ans;
                  }
                }
              }
            }
            if (eltToFindNotNull && v.equals(eltToFind)) {
              if (reportNotNull) report.addEndingLine("closing done, found "
                                               + eltToFind + ", at " + ans.size());
              return ans;
            }
            // the get is  likely to be null so do it in this order.
            if (eltsToFindNotNull  && minusOne.equals(indecesMapOfFoundElts.get(v))) {
              final int index = ans.size() - 1;
              indecesMapOfFoundElts.put(v, index);
              specialEltsFound++;
              if (reportNotNull) report.addLine("found " + v + ", at " + index);
              if (specialEltsFound == eltsToFind.size()) {
                if (reportNotNull) report.addEndingLine("closing done, found all "
                    + eltsToFind.size() + " elems ");
                allEltsFound = true;
                return ans;
              }
            }
            
            // cannot do this exit if we are searching  for an equation !!!!!
            if (imgAlgNull) {
              if (algebra.cardinality() > 0 && ans.size() == algebra.cardinality()) {
                if (reportNotNull) {
                  report.addEndingLine("found all " + ans.size() + " elements");
                  report.setSize(ans.size());
                }
                return ans;
              }
            }
            else {
              final int[] args = new int[arity];
              for (int t = 0; t < arity; t++) {
                args[t] = homomorphism.get(ans.get(argIndeces[t]));
              }
              homomorphism.put(v, imgOps.get(i).intValueAt(args));
            }
            
            
          }
          else {
            if (imgOps != null) {
              final int[] args = new int[arity];
              for (int t = 0; t < arity; t++) {
                args[t] = homomorphism.get(ans.get(argIndeces[t]));
              }
              if (homomorphism.get(v).intValue() != imgOps.get(i).intValueAt(args)) {
                List<Term> children = new ArrayList<Term>(arity);
                for (int r = 0; r < arity; r++) {
                  //children.set(i, termMap.get(arg.get(i)));
                  children.add(termMap.get(ans.get(argIndeces[r])));
                }
                failingEquation = new Equation(termMap.get(v),
                    new NonVariableTerm(imgOps.get(i).symbol(), children));
                final String line = "failing equation:\n" + failingEquation;
                if (reportNotNull) {
                  report.setSize(ans.size());
                  report.addEndingLine(line);
                }
                else {
                  System.out.println("failing equation:\n" + failingEquation);
                  System.out.println("size so far: " + ans.size());
                }
                return ans;
              }
            }
          }
          if (!inc.increment()) break;
        }
if (false) {
/*
  List middleZero = new ArrayList();
    for (Iterator it2 = lst.iterator(); it2.hasNext(); ) {
      IntArray ia = (IntArray)it2.next();
      if (ia.get(1) == 0) middleZero.add(ia);
    }
  System.out.println("jonsson level so far: "
     + Algebras.jonssonLevelAux(middleZero, 
                             (IntArray)lst.get(0),  (IntArray)lst.get(2)));
*/
}
      }
      closedMark = currentMark;
      currentMark = ans.size();
      if (imgAlgNull && algebra.cardinality() > 0 && currentMark >= algebra.cardinality()) break;
    }
    if (reportNotNull) report.addEndingLine("closing done, size = " + ans.size());
    completed = true;
    return ans;
  }
  
  /**
   * Parallel version of <code>sgClose</code>. Only works for powers, right now.
   * @param numThreads The number of threads to use (0=number of available cores)
   * @return A list of IntArray's
   */
  public List<IntArray> sgCloseParallel( int numThreads, int indicesPerChunk ) {
	  if ( numThreads==0 ) numThreads=Runtime.getRuntime().availableProcessors();
	  if ( algebra.isPower() ) {
		  SmallAlgebra alg = algebra.rootFactors().get(0);
		  alg.makeOperationTables();
		  return sgClosePowerParallel(generators,0,termMap, numThreads, indicesPerChunk, numThreads>8);
	  }
	  return null;
	  // Not Implemented Yet
  }
  
  /**
   * Closure of <tt>elems</tt> under the operations. (Worry about
   * nullary ops later.)
   *
   * @param elems a List of IntArray's
   *
   * @param termMap a Map from the element to the corresponding term
   *                used to generated it. The generators should be 
   *                already in the Map. In other words the termMap
   *                should have the same number of entries as elems.
   *
   * @return a List of IntArray's.
   */
  public List<IntArray> sgCloseParallel(List<IntArray> elems, int closedMark, 
                                        Map<IntArray,Term> termMap) {
    
    if (algebra.isPower()) {
      SmallAlgebra alg = algebra.rootFactors().get(0);
      alg.makeOperationTables();
      return sgClosePower(elems, closedMark, termMap);
    }
    
    if (report != null) report.addStartLine("parallel subpower closing ...");

    final int numOfOps = algebra.operations().size();  
    List<Operation> imgOps = null;
    if (homomorphism != null) {
      imgOps = new ArrayList<Operation>(numOfOps);
      for (Operation op : algebra.operations()) {
        imgOps.add(imageAlgebra.getOperation(op.symbol()));
      }
    }
    
    // these final boolean are meant to help the jit compiler.
    final boolean reportNotNull = report == null ? false : true;
    final boolean imgAlgNull = imgOps == null ? true : false;
    final boolean eltToFindNotNull = eltToFind == null ? false : true;
    final boolean eltsToFindNotNull = eltsToFind == null ? false : true;
    final boolean operationsNotNull = operations == null ? false : true;

    elems = Collections.synchronizedList(elems);
    ans = Collections.synchronizedList(new ArrayList<IntArray>(elems));// IntArrays
    final List<int[]> rawList = Collections.synchronizedList(new ArrayList<int[]>()); // the corr raw int[]
    synchronized(elems) {
      for (Iterator<IntArray> it = elems.iterator(); it.hasNext(); ) {
        rawList.add(it.next().getArray());
      }
    }
    termMap = new ConcurrentHashMap<IntArray,Term>(termMap);
    //final HashSet<IntArray> su = new HashSet<IntArray>(ans);
    int currentMark = ans.size();
    int pass = 0;
    CloserTiming timing = null; 
    if (reportNotNull) timing = new CloserTiming(algebra, report);
    //int currPassSize = 0; // for time left
    //int lastPassSize = 0; // for time left
    //final int numberProjs = algebra.getNumberOfFactors(); // for time left
    while (closedMark < currentMark) {
      if (reportNotNull) timing.updatePass(ans.size());
      //lastPassSize = currPassSize;
      //currPassSize = ans.size();
      //long funcAppsNeeded = countFuncApplications(lastPassSize, currPassSize);
      //long appsSoFar = 0;
      String str = "pass: " + pass + ", size: " + ans.size();
      if (reportNotNull) {
        report.setPass(pass);
        report.setPassSize(ans.size());
        if (!suppressOutput) report.addLine(str);
      }
      else {
        if (!suppressOutput) System.out.println(str);
      }
      pass++;
      if (Thread.currentThread().isInterrupted()) {
        if (reportNotNull) report.addEndingLine("cancelled ...");
        return null;
      }
      CountDownLatch latch = new CountDownLatch(nCPUs);
      ConcurrentHashMap<IntArray,Term> map = new ConcurrentHashMap<IntArray,Term>();
      for (int i = 0; i < nCPUs; ++i) {// create and start threads
        new Thread(new ParallelWorker(latch, i, map, numOfOps, closedMark, currentMark, reportNotNull, rawList, timing)).start();
      }
      try {
        latch.await();
      }
      catch (InterruptedException e) { return null; }  // also write to the report.
      
      
      System.out.println("map: " + map);
      for (IntArray ia : map.keySet()) {
        System.out.println("ia: " + ia + ", term: " + map.get(ia));
        ans.add(ia);
        rawList.add(ia.getArray());
        termMap.put(ia, map.get(ia));
      }
      
      
      
      closedMark = currentMark;
      currentMark = ans.size();
      if (imgAlgNull && algebra.cardinality() > 0 && currentMark >= algebra.cardinality()) break;
    }
    if (reportNotNull) report.addEndingLine("closing done, size = " + ans.size());
    completed = true;
    return ans;
  }
  
  public List<IntArray> sgClosePower() {
    //System.out.println("gens = " + generators);
    //System.out.println("termMap = " + termMap);
    return sgClosePower(generators, 0, termMap);
  }
  
  /**
   * A fast version for powers to compute the 
   * closure of <tt>elems</tt> under the operations. (Worry about
   * nullary ops later.)
   *
   * @param elems a List of IntArray's
   *
   * @param termMap a Map from the element to the corresponding term
   *                used to generated it. The generators should be 
   *                already in the Map. In other words the termMap
   *                should have the same number of entries as elems.
   *
   * @return a List of IntArray's.
   */
  private final List<IntArray> sgClosePower(
                     List<IntArray> elems, int closedMark, 
                     final Map<IntArray,Term> termMap) {
    //System.out.println("elems: " + elems);
    //System.out.println("termMap: " + termMap);
    if (report != null) report.addStartLine("subpower closing ...");
    final int algSize = algebra.factors().get(0).cardinality();
    final List<Operation> ops = algebra.factors().get(0).operations();
    final int k = ops.size();
    final int[][] opTables = new int[k][];
    final int[] arities = new int[k];
    final OperationSymbol[] symbols = new OperationSymbol[k];
    final Operation[] imgOps = 
      (homomorphism != null && imageAlgebra != null  && termMap != null) 
          ? new Operation[k] : null;
    boolean nullTable = false;
    for (int i = 0; i < k; i++) {
      Operation op = ops.get(i);
      if (op instanceof OperationWithDefaultValue) {
        opTables[i] = ((OperationWithDefaultValue)op).getTotalTable();
      }
      else {
        opTables[i] = op.getTable();
        if (opTables[i] == null) nullTable = true;
      }
      //System.out.println("nullTable = " + nullTable);
      arities[i] = op.arity();
      symbols[i] = op.symbol();
      if (imgOps != null) imgOps[i] = imageAlgebra.getOperation(op.symbol());
    }
    //if (k > 0) System.out.println("opTable[0] = " + opTables[0]);
 //   List<Operation> imgOps = null;
//    Operation[] imgOps;
 //   if (homomorphism != null && imageAlgebra != null) {
 //     imgOps = new ArrayList<Operation>(imageAlgebra.operations().size());
      
  //  }
    
    // these final boolean are meant to help the jit compiler.
    final boolean reportNotNull = report == null ? false : true;
    final boolean imgAlgNull = imgOps == null ? true : false;
    final boolean eltToFindNotNull = eltToFind == null ? false : true;
    final boolean eltsToFindNotNull = eltsToFind == null ? false : true;
    final boolean operationsNotNull = operations == null ? false : true;
    final boolean blocksNotNull = blocks == null ? false : true;
    final boolean valuesNotNull = values == null ? false : true;
    
    if (operationsNotNull) termMapForOperations = new HashMap<Operation,Term>();
    int operationsFound = 0;
    
    //System.out.println("got to sgClosePower, reportNotNull: " + reportNotNull);
    final int power = algebra.getNumberOfFactors();
    ans = new ArrayList<IntArray>(elems);// IntArrays
    final List<int[]> rawList = new ArrayList<int[]>(); // the corresponding raw int[]'s
    for (IntArray arr : elems) {
      rawList.add(arr.getArray());
    }
    final HashSet<IntArray> su = new HashSet<IntArray>(ans);
    //         Code to add the constants
    final List<IntArray> constants = algebra.getConstants();// add the constants, if any
    for (IntArray arr : constants) {
      if (su.add(arr)) {
        ans.add(arr);
        rawList.add(arr.getArray());
        if (termMap != null) {
          termMap.put(arr, NonVariableTerm.makeConstantTerm(algebra.constantToSymbol.get(arr)));
        }
      }
    }
    int currentMark = ans.size();
    int pass = 0;
    final CloserTiming timing = reportNotNull ?  new CloserTiming(algebra, report) : null;
    //vvv;
    while (closedMark < currentMark) {
      String str = "pass: " + pass + ", size: " + ans.size();
      if (reportNotNull) {
        timing.updatePass(ans.size());
        report.setPass(pass);
        report.setPassSize(ans.size());
        if (!suppressOutput) report.addLine(str);
      }
      else {
        if (!suppressOutput) System.out.println(str);
      }
      if (maxSize > 0 && ans.size() >= maxSize) return ans;
      pass++;
      // close the elements in current
      for (int i = 0; i < k; i++) {
        final int arity = arities[i];
        if (arity == 0) continue;  // worry about constansts later
        final int[] opTable = opTables[i];
        final int[] argIndeces = new int[arity];
        for (int r = 0; r < arity - 1; r++) {
          argIndeces[r] = 0;
        }
        argIndeces[arity - 1] = closedMark;
        ArrayIncrementor inc =
                    SequenceGenerator.sequenceIncrementor(
                                  argIndeces, currentMark - 1, closedMark);
        while (true) {
          if (Thread.currentThread().isInterrupted()) {
            if (reportNotNull) {
              report.setSize(ans.size());
              report.addEndingLine("cancelled ...");
            }
            return null;
          }
          //for (int i = 0; i < arity; i++) {
          //  arg[i] = rawList.get(argIndeces[i]);
          //}
          final int[] vRaw = new int[power];

//yyy;
          if (opTable != null) {
            for (int j = 0; j < power; j++) {
              int factor = algSize;
              int index = rawList.get(argIndeces[0])[j];
              for (int r = 1; r < arity; r++) {
                index += factor * rawList.get(argIndeces[r])[j];
                factor = factor * algSize;
              }
              vRaw[j] = opTable[index];
            }
          }
            
          else {
            final Operation f = ops.get(i);
            for (int j = 0; j < power; j++) {
              final int[] arg = new int[f.arity()];
              for (int r = 0; r < arity; r++) {
                arg[r] = rawList.get(argIndeces[r])[j];
              }
              vRaw[j] = f.intValueAt(arg);
            }
          }
          IntArray v = new IntArray(vRaw);
          if (reportNotNull) timing.incrementApps();
          if (su.add(v)) {
            ans.add(v);
            rawList.add(vRaw);
            if (reportNotNull) timing.incrementNextPassSize();
            if (reportNotNull) report.setSize(ans.size());
            if (Thread.currentThread().isInterrupted()) return null;
            if (termMap != null) {
              List<Term> children = new ArrayList<Term>(arity);
              for (int r = 0; r < arity; r++) {
                //children.set(i, termMap.get(arg.get(i)));
                children.add(termMap.get(ans.get(argIndeces[r])));
              }
              termMap.put(v, new NonVariableTerm(symbols[i], children));
              //logger.fine("" + v + " from " + f.symbol() + " on " + arg);
              if (operationsNotNull) {
                Term term = termMap.get(v);
                // why are recreating vars each time ???
                List<Variable> vars = new ArrayList<Variable>(generators.size());
                for (IntArray ia : generators) {
                  vars.add((Variable)termMap.get(ia));
                }
                Operation termOp = term.interpretation(rootAlgebra, vars, true);
                for (Operation op : operations) {
                  if (Operations.equalValues(termOp, op)) {
                    termMapForOperations.put(op, term);
                    operationsFound++;
                    if (operationsFound == operations.size()) return ans;
                  }
                }
              }
            }
            if (eltToFindNotNull && v.equals(eltToFind)) {
              if (reportNotNull) {
                report.setSize(ans.size());
                report.addEndingLine("closing done, found "
                    + eltToFind + ", at " + ans.size());
              }
              return ans;
            }
            // the get is  likely to be null so do it in this order.
            if (eltsToFindNotNull  && minusOne.equals(indecesMapOfFoundElts.get(v))) {
              final int index = ans.size() - 1;
              indecesMapOfFoundElts.put(v, index);
              specialEltsFound++;
              System.out.println("found " + v);
              if (reportNotNull) report.addLine("found " + v + ", at " + index);
              if (specialEltsFound == eltsToFind.size()) {
                if (reportNotNull) report.addEndingLine("closing done, found all "
                    + eltsToFind.size() + " elems ");
                allEltsFound = true;
                return ans;
              }
            }
            if (blocksNotNull) {  // this assumes that if values != null then so is blocks
              boolean found = false;
              if (valuesNotNull) {  
                if (v.satisfiesConstraint(blocks, values)) found = true;
              }
              else {
                if (v.satisfiesConstraint(blocks)) found = true;
              }
              if (found) {
                eltToFind = v;
                if (reportNotNull) {
                  report.setSize(ans.size());
                  report.addEndingLine("closing done, found "
                      + eltToFind + ", at " + ans.size());
                }
                return ans;
              }
            }
            
            // can't quit early if we are looking for a homomorphism
            if (imgOps == null) {
              final int size = ans.size();
              if (imgAlgNull && algebra.cardinality() > 0 && size == algebra.cardinality()) {  
                if (reportNotNull) {
                  report.addEndingLine("found all " + size + " elements");
                  report.setSize(ans.size());
                }
                return ans;
              }
            }
            else {
              final int[] args = new int[arity];
              for (int t = 0; t < arity; t++) {
                args[t] = homomorphism.get(ans.get(argIndeces[t]));
              }
              homomorphism.put(v, imgOps[i].intValueAt(args));
            }
            if (Thread.currentThread().isInterrupted()) {
              if (reportNotNull) {
                report.setSize(ans.size());
                report.addEndingLine("cancelled ...");
              }
              return null;
            }
            
          }
          else {
            if (!imgAlgNull) {
              // here
              final int[] args = new int[arity];
              for (int t = 0; t < arity; t++) {
                args[t] = homomorphism.get(ans.get(argIndeces[t]));
              }
              if (homomorphism.get(v).intValue() != imgOps[i].intValueAt(args)) {
                List<Term> children = new ArrayList<Term>(arity);
                for (int r = 0; r < arity; r++) {
                  //children.set(i, termMap.get(arg.get(i)));
                  children.add(termMap.get(ans.get(argIndeces[r])));
                }
                failingEquation = new Equation(termMap.get(v),
                    new NonVariableTerm(symbols[i], children));
                final String line = "failing equation:\n" + failingEquation;
                if (reportNotNull) {
                  report.setSize(ans.size());
                  report.addEndingLine(line);
                }
                else {
                  System.out.println("failing equation:\n" + failingEquation);
                  System.out.println("size so far: " + ans.size());
                }
                return ans;
              }
            }
          }
          if (!inc.increment()) break;
        }

if (false) {
/*
  List middleZero = new ArrayList();
    for (Iterator it2 = ans.iterator(); it2.hasNext(); ) {
      IntArray ia = (IntArray)it2.next();
      if (ia.get(1) == 0) middleZero.add(ia);
    }
  System.out.println("jonsson level so far: "
     + Algebras.jonssonLevelAux(middleZero, 
                             (IntArray)ans.get(0),  (IntArray)ans.get(2)));
*/
}
      }
      closedMark = currentMark;
      currentMark = ans.size();
      if (imgAlgNull && algebra.cardinality() > 0 && currentMark >= algebra.cardinality()) break;
//System.out.println("so far: " + currentMark);
//if (currentMark > 7) return ans;
    }
    
    if (reportNotNull) {
      final String str = "done closing, size = " + ans.size();
      report.setSize(ans.size());
      report.addEndingLine(str);
    }
    //else System.out.println(str);
    completed = true;
    return ans;
  }
  
  
  /**
   * Parallel version of <code>sgClosePower</code>. 
   * Does not look for homomorphisms or failing equations (yet).
   * @param numThreads The number of threads to use (0=number of available cores)
   * @param indicesPerChunk - the number of indices to be placed in each calculation chunk
   */
  private final List<IntArray> sgClosePowerParallel(List<IntArray> elems, int closedMark, Map<IntArray,Term> termMap, int numThreads, final int indicesPerChunk, boolean splitFeeder) {
      if ( numThreads==0 ) numThreads=Runtime.getRuntime().availableProcessors();  
	  final int numWorkers=splitFeeder?numThreads-2:numThreads-1;
	  if (report!=null) report.addStartLine("subpower closing ("+numWorkers+" workers)...");
	  final int algSize = algebra.factors().get(0).cardinality();
	  final List<Operation> ops = algebra.factors().get(0).operations();
	  final int k = ops.size();
	  final int[][] opTables = new int[k][];
	  final int[] arities = new int[k];
	  final OperationSymbol[] symbols = new OperationSymbol[k];
//	  boolean nullTable = false;
	  for (int i = 0; i < k; i++) {
		  Operation op = ops.get(i);
		  if (op instanceof OperationWithDefaultValue) {
			  opTables[i] = ((OperationWithDefaultValue)op).getTotalTable();
		  } else {
	          opTables[i] = op.getTable();
//	          if (opTables[i] == null) nullTable = true;
	      } // end if-else (op instanceof OperationWIthDefaultValue)
		  arities[i] = op.arity();
	      symbols[i] = op.symbol();
	  } // end for 0 <= i < k
	  final boolean reportNotNull = report == null ? false : true;
	  final boolean eltToFindNotNull = eltToFind == null ? false : true;
	  final boolean eltsToFindNotNull = eltsToFind == null ? false : true;
	  final boolean operationsNotNull = operations == null ? false : true;
	  final boolean blocksNotNull = blocks == null ? false : true;
	  final boolean valuesNotNull = values == null ? false : true;
	  if (operationsNotNull) termMapForOperations = new HashMap<Operation,Term>();
	  int operationsFound = 0;
	    
	  if ( termMap==null ) {
		  termMap = new HashMap<IntArray,Term>();
		  for ( int i = 0; i < generators.size(); i++ ) {
			  termMap.put(generators.get(i), new VariableImp("x"+i));
		  } // end for 0 <= i < generators.size()
	  } // end if ( termMap==null )
	  final int power = algebra.getNumberOfFactors();
	  ans = new ArrayList<IntArray>(elems);// IntArrays
	  final List<int[]> rawList = new ArrayList<int[]>(); // the corresponding raw int[]'s
	  for (IntArray arr : elems) {
		  rawList.add(arr.getArray());
	  } // end for (IntArray arr : elems )
	  final HashSet<IntArray> su = new HashSet<IntArray>(ans);
	  //         Code to add the constants
	  final List<IntArray> constants = algebra.getConstants();// add the constants, if any
	  for (IntArray arr : constants) {
		  if (su.add(arr)) {
			  ans.add(arr);
			  rawList.add(arr.getArray());
			  if (termMap != null) {
				  termMap.put(arr, NonVariableTerm.makeConstantTerm(algebra.constantToSymbol.get(arr)));
			  } // end if (termMap!=null)
		  } // end if (su.add(arr))
	  } // end for (Intarray arr : constants)
	  int currentMark = ans.size();
	  int pass = 0;
//	  final CloserTiming timing = reportNotNull ?  new CloserTiming(algebra, report) : null;
	  HashMap<IntArray,Term> partResult = null;
//	  double eltsPerNS = 0;
	  long passStartTime = 0;
	  long passFinishTime = 0;
	  long chunksProcessedThisPass=0;
	  while ( closedMark < currentMark ) { // for each pass
		  // Report which pass we're on
	      String str = "pass: " + pass + ", size: " + ans.size() + "("+(passFinishTime-passStartTime)+"ms)";
	      passStartTime = System.currentTimeMillis();
	      if (reportNotNull) {
//	    	  timing.updatePass(ans.size());
	    	  report.setPass(pass);
	    	  report.setPassSize(ans.size());
	    	  if (!suppressOutput) report.addLine(str);
	      } else {
	    	  if (!suppressOutput) System.out.println(str);
	      } // end if-else (reportNotNull)
		  int unusedPasses=0;
	      final LinkedBlockingQueue<SGClosePowerThread.SGClosePowerChunk> feeder = new LinkedBlockingQueue<SGClosePowerThread.SGClosePowerChunk>(FEEDER_CAPACITY);
	      final LinkedBlockingQueue<SGClosePowerThread.SGClosePowerResult> collector = new LinkedBlockingQueue<SGClosePowerThread.SGClosePowerResult>();
	      SGClosePowerThread[] workers = new SGClosePowerThread[numWorkers]; 
	      boolean[] workersFinished = new boolean[numWorkers];
	      HashMap<IntArray,Term> prevTermMap = null;
    	  prevTermMap = new HashMap<IntArray,Term>();
    	  prevTermMap.putAll(termMap);
	      for ( int i = 0; i < numWorkers; i++) {
	    	  workers[i] = new SGClosePowerThread(feeder,power,opTables,algSize,arities,indicesPerChunk,closedMark,currentMark,rawList,ops,prevTermMap,symbols,collector,i,null,null,0);
//	    	  workers[i].setPriority(Thread.MIN_PRIORITY);
	    	  workersFinished[i]=false;
	    	  workers[i].start();
	      } // end for 0 <= i < numWorkers
		  pass++;
		  chunksProcessedThisPass=0;
		  long eltsPerChunk=1;
		  for ( int i = 0; i < indicesPerChunk; i++ ) {
			  eltsPerChunk=eltsPerChunk*currentMark;
		  } // end for 0 <= i < indicesPerChunk		  
		  int chunksToGenerate = 0;
		  for ( int r = 0; r < k; r++ ) {
			  int temp = 1;
			  for ( int i = 0; i < (arities[r]>indicesPerChunk?arities[r]-indicesPerChunk:0); i++ ) {
				  temp = temp*currentMark;
			  } // end for 0 <= i < (arities[r]>indicesPerChunk?arities[r]-indicesPerChunk:0)
			  chunksToGenerate+=temp;
		  } // end for 0 <= r < k
		  
		  final int maxIndex = currentMark-1;
		  
		  /**
		   * This class fills the feeder <code>java.util.concurrent.BlockingQueue</code> in a separate thread.
		   * @author Jonah Horowitz
		   */
		  class SGFeederRunner implements Runnable {
			  private int opIndex=-1;
			  private int arity;
			  private SequenceIterator intArrayGen;
			  private SGClosePowerThread.SGClosePowerChunk tempChunk = null;
			  
			  public SGFeederRunner() {
				  nextOp();
			  } // constructor()
			  
			  private void nextOp() {
				  tempChunk=null;
				  opIndex++;
				  if ( opIndex>=k ) return;
				  arity=arities[opIndex];
				  while ( arity==0 && opIndex<k ) {
					  opIndex++;
					  arity=arities[opIndex];
				  } // end while ( arity==0 && opIndex<k )
				  int[] tempSegment = new int[arity<=indicesPerChunk?0:arity-indicesPerChunk];
				  for ( int i = 0; i < tempSegment.length; i++ ) {
					  tempSegment[i]=0;
				  } // end for 0 <= i < tempSegment.length;
				  intArrayGen=new SequenceIterator(tempSegment,maxIndex,0);
			  } // end nextOp()
			  
			  public boolean hasMore() {
				  return opIndex<k;
			  } // end hasMore()
			  
			  public void fillQueue() {
				  while ( opIndex < k  && feeder.remainingCapacity()!=0 ) {
					  if ( tempChunk!=null && !feeder.offer(tempChunk) ) return;
					  if ( !intArrayGen.hasNext() ) nextOp();
					  tempChunk=new SGClosePowerThread.SGClosePowerChunk(opIndex,intArrayGen.next());
				  } // end while ( opIndex<k && feeder.remainingCapacity()!=0 )
			  } // end fillQueue()
			  
			  @Override
			  public void run() {
				  while ( hasMore() ) {
					  fillQueue();
					  try {
						  Thread.sleep(SGClosePowerThread.SLEEP_TIME);
					  } catch ( InterruptedException e ) {}
				  } // end while ( hasMore() )
				  while ( feeder.remainingCapacity()<numWorkers ) {
					  try {
						  Thread.sleep(SGClosePowerThread.SLEEP_TIME);
					  } catch ( InterruptedException e ) {}
				  } // end while ( feeder.remainingCapacity()<numWorkers )
				  for ( int i = 0; i < numWorkers; i++ ) {
					  feeder.offer(SGClosePowerThread.STOP_COMMAND);
				  } // end for 0 <= i < numWorkers
			  } // end run()
		  } // end class SGFeederRunner
		  
		  SGFeederRunner feederRunner = new SGFeederRunner();
		  Thread feederThread = null;
		  if ( splitFeeder ) {
			  feederThread = new Thread(feederRunner);
			  feederThread.start();
		  } // end if ( splitFeeder )
/*		  int opIndex = 0;
		  SGClosePowerChunk tempChunk = null;
		  int arity = arities[opIndex];
		  while ( arity==0 && opIndex < k) {
			  opIndex++;
			  if ( opIndex < k ) arity=arities[opIndex];
		  } // end while ( arity==0 && opIndex < k )
		  int[] tempSegment = new int[arity<=indicesPerChunk?0:arity-indicesPerChunk];
		  for ( int i = 0; i < tempSegment.length; i++ ) {
			  tempSegment[i]=0;
		  } // end for 0 <= i < tempSegment.length
		  SequenceIterator intArrayGen = new SequenceIterator(tempSegment,currentMark-1,0);/**/
		  while (true) {
			  // check for task cancellation
			  if (Thread.currentThread().isInterrupted()) {
				  for ( int i = 0; i < numWorkers; i++ ) {
					  if ( workers[i]!=null && workers[i].isAlive() ) {
						  try {
							  workers[i].interrupt();
						  } catch ( SecurityException e ) {
							  if (reportNotNull) report.addLine("Could not cancel worker thread number " + i + ".");							  
							  System.err.println("Could not cancel worker thread number " + i + ".");
							  e.printStackTrace(System.err);
						  } // end try-catch (SecurityException)
					  } // end if ( workers[i]!=null && workers[i].isAlive() )
				  } // end for 0 <= i < numWorkers
				  if (reportNotNull) {
					  report.setSize(ans.size()); 
					  report.addEndingLine("cancelled...");
				  } // end if (reportNotNull)
				  return null;
			  } // end if (Thread.currentThread().isInterrupted())
			  
			  if ( !splitFeeder ) {
				  feederRunner.fillQueue();
				  if ( !feederRunner.hasMore() ) {
					  if ( feeder.remainingCapacity()>=numWorkers ) {
						  for ( int i = 0; i < numWorkers; i++ ) {
							  feeder.offer(SGClosePowerThread.STOP_COMMAND);
						  } // end for 0 <= i < numWorkers
					  } // end if ( feeder.remainingCapacity()>=numWorkers )
				  } // end if ( !feederRunner.hasMore() )
			  } // end if ( !splitFeeder )
			  // Fill the feeder queue
/*			  while ( opIndex<k ) {
				  if ( tempChunk!=null && !feeder.offer(tempChunk) ) break;			
				  if ( intArrayGen.hasNext() ) {
					  tempChunk = new SGClosePowerChunk(opIndex,intArrayGen.next());
					  chunksToGenerate--;
				  } else {
					  tempChunk=null;
					  opIndex++;
					  if ( opIndex>=k ) break;
					  arity=arities[opIndex];
					  while ( arity==0 && opIndex<k ) {
						  opIndex++;
						  arity=arities[opIndex];
					  } // end while ( arity==0 && opIndex<k )
					  if ( opIndex>= k ) break;
					  tempSegment = new int[arity<=indicesPerChunk?0:arity-indicesPerChunk];
					  for ( int i = 0; i < tempSegment.length; i++ ) {
						  tempSegment[i]=0;
					  } // end for 0 <= i < tempSegment.length
					  intArrayGen = new SequenceIterator(tempSegment,currentMark-1,0);
				  } // end if-else ( intArrayGen.hasNext() )
			  } // end while (true)/**/
			  
			  // check for completion of pass, notify workers
/*			  if ( opIndex>=k ) {
				  if ( feeder.remainingCapacity() >= numThreads-1 ) {
					  for ( int i = 0; i < numThreads-1; i++ ) {
						  feeder.offer(SGClosePowerThread.STOP_COMMAND);
					  } // end for 0 <= i < numThreads-1
				  } // end if ( feeder.remainingCapacity() >= numThreads-1 )
			  } // end if ( opIndex>=k )/**/
			  
			  if ( collector.size()==0 ) unusedPasses++;
			  if ( unusedPasses>=100 ) {
				  try {
					  Thread.sleep(1000);
				  } catch ( InterruptedException e ) {}
				  unusedPasses=0;
			  }
//			  System.err.println("Collector size: " + collector.size()); // DEBUG
			  for ( int q = 0; q < PROCESS_PER_LOOP; q++ ) {
			  // collect and evaluate partial answers
				  if ( collector.size() == 0 ) break;
			  partResult = collector.poll().termMap;
			  if ( partResult!=null && partResult.size()==1 && partResult.containsValue(null) ) {
				  workersFinished[((IntArray)partResult.keySet().toArray()[0]).get(0)] = true;
			  } else if ( partResult!=null ) {
				  chunksProcessedThisPass++;
				  List<IntArray> partAns = new ArrayList<IntArray>(partResult.keySet());
				  for ( IntArray v : partAns ) {
					  if ( su.add(v) ) {
						  ans.add(v);
						  rawList.add(v.getArray());
//						  if (reportNotNull) timing.incrementNextPassSize();
						  if ( termMap != null ) {
							  termMap.put(v, partResult.get(v));
							  if ( operationsNotNull ) {
								  Term term = partResult.get(v);
								  List<Variable> vars = new ArrayList<Variable>(generators.size());
								  for ( IntArray ia : generators ) {
									  vars.add((Variable)termMap.get(ia));
								  } // end for ( IntArray ia : generators )
								  Operation termOp = term.interpretation(rootAlgebra, vars, true);
					              for (Operation op : operations) {
					                  if (Operations.equalValues(termOp, op)) {
					                	  termMapForOperations.put(op, term);
					                	  operationsFound++;
					                	  if (operationsFound == operations.size()) return ans;
					                  } // end if ( Operations.equalValues(termOp, op) )
					              } // end for ( Operation op : operations )					              
							  } // end if ( operationsNotNull )
						  } // end if ( termMap != null )
						  if ( eltToFindNotNull && v.equals(eltToFind) ) {
							  if ( reportNotNull ) {
								  report.setSize(ans.size()); 
								  report.addEndingLine("Closing done, found " + eltToFind + ", at " + ans.size());
							  } // end if ( reportNotNull )
							  return ans;
						  } // end if ( eltToFindNotNull && v.equals(eltToFind) )
						  if ( eltsToFindNotNull && minusOne.equals(indecesMapOfFoundElts.get(v)) ) {
							  final int index = ans.size()-1;
							  indecesMapOfFoundElts.put(v, index);
							  specialEltsFound++;
							  System.out.println("Found " + v);
							  if (reportNotNull) report.addLine("Found " + v + ", at " + index);
							  if ( specialEltsFound == eltsToFind.size() ) {
								  if (reportNotNull) report.addEndingLine("Closing done, found all " + specialEltsFound + " elements.");
								  allEltsFound = true;
								  return ans;
							  } // end if ( specialEltsFound == eltsToFind.size() )
						  } // end if ( eltsToFindNotNull && minusOne.equals(indecesMapOfFoundElts.get(v)) )
						  if ( blocksNotNull ) {
							  boolean found = false;
							  if ( valuesNotNull ) {
								  if ( v.satisfiesConstraint(blocks,values) ) found = true;
							  } else {
								  if ( v.satisfiesConstraint(blocks) ) found = true;
							  } // end if-else ( valuesNotNull )
							  if (found) {
								  eltToFind = v;
								  if (reportNotNull) {
									  report.setSize(ans.size()); 
									  report.addEndingLine("Closing done, found " + eltToFind + ", at " + ans.size() );
								  } // end if (reportNotNull)
								  return ans;
							  } // end if (found)
						  } // end if ( blocksNotNull )
						  final int size = ans.size();
						  if ( algebra.cardinality()>0 && size==algebra.cardinality() ) {
							  if (reportNotNull) {
								  report.setSize(size);
								  report.addEndingLine("Found all " + size + " elements.");
							  } // end if (reportNotNull)
							  return ans;
						  } // end if ( algebra.cardinality()>0 && size==algebra.cardinality() )
					  } // end if ( su.add(v) )
				  } // end for ( IntArray v : partAns )
			  } // end else if ( partResult != null )
			  } // end for 0 <= q < PROCESS_PER_LOOP
			  
			  // check for dead workers, print their stack trace to the error stream and notify the user
			  for ( int i = 0; i < numWorkers; i++ ) {
				  if ( workers[i]!=null && !workers[i].isAlive() && workers[i].getStatus()==SGClosePowerThread.RUNNING ) {
					  System.err.println("Uncaught exception in worker thread number " + i + ".");
					  StackTraceElement[] blah = workers[i].getStackTrace();
					  for ( int j = 0; j < blah.length; j++ ) {
						  System.err.println(blah[j]);
					  }
					  workers[i]=null;
					  if (reportNotNull) report.addLine("Worker " + i + " has died unexpectedly.");
				  } // end if ( !workers[i].isAlive() && workers[i].status.getStatus()==SmallThreadsafeProgressReport.RUNNING )
			  } // end for 0 <= i < numWorkers

			  // For timing and reporting
/*			  double chunksPerNS = 0;
			  for ( int i = 0; i < numThreads-1; i++ ) {
				  if ( workers[i] != null ) chunksPerNS+=workers[i].status.getChunksPerNS();
			  } // end for 0 <= i < numThreads-1
			  if ( chunksPerNS <= 0 ) System.err.println("chunksPerNS: " + chunksPerNS);/**/

			  // check for completion of work this pass
			  boolean allDone = true;
			  for ( int i = 0; i < numWorkers; i++ ) {
				  allDone = allDone && workersFinished[i];
			  } // for 0 <= i < numThreads-1
			  if ( allDone ) {
//				  eltsPerNS=(eltsPerNS+eltsPerChunk*chunksPerNS)/2;
				  break;			  
			  } // end if ( allDone )

			  // calculate the timing of it all
			  if (reportNotNull) {
				  report.setSize(ans.size());
				  if ( chunksProcessedThisPass > 0 ) {
					  report.setTimeLeft(nsToString((chunksToGenerate+feeder.size())*(System.currentTimeMillis()-passStartTime)/chunksProcessedThisPass));
				  } else {
					  report.setTimeLeft("Unknown");
				  } // end if-else ( chunksProcessedThisPass > 0 )
/*				  if ( chunksPerNS > 0 ) {
					  report.setTimeLeft(nsToString((chunksToGenerate+feeder.size())/chunksPerNS));
				  } else {
					  report.setTimeLeft("Unknown");
				  } // end if-else ( chunksPerNS > 0 )/**/
				  long futureElts = 0;
				  long size = ans.size();
				  for ( int r = 0; r < k; r++ ) {
					  long temp = 1;
					  long temp2 = 1;
					  for ( int i = 0; i < arities[r]; i++ ) {
						  temp=temp*size;
						  temp2=temp2*currentMark;
					  } // end for 0 <= i < arities[r]
					  futureElts+=temp-temp2;
				  } // end for 0 <= r < k
				  if ( chunksProcessedThisPass > 0 ) {
					  report.setTimeNext(nsToString(futureElts*(System.currentTimeMillis()-passStartTime)/(eltsPerChunk*chunksProcessedThisPass)));
				  } else {
					  report.setTimeLeft("Unknown");
				  }
/*				  double denom = eltsPerNS+eltsPerChunk*chunksPerNS;
				  if ( denom > 0 ) {
					  report.setTimeNext(nsToString(futureElts/denom));
				  } else {
					  report.setTimeNext("Unknown");
				  } // end if-else ( denom > 0 )/**/
			  } // if (reportNotNull)
		  } // end while (true)
		  closedMark=currentMark;
		  currentMark=ans.size();
		  passFinishTime = System.currentTimeMillis();
	  } // end while ( closedMark < currentMark )
	  if (reportNotNull) {
	      final String str = "done closing, size = " + ans.size();
	      report.setSize(ans.size());
	      report.addEndingLine(str);
	  } // end if (reportNotNull)
      completed = true;
      if ( writeTermMapOnComplete!=null ) {
    	  try {
    		  TermMapWriter.writeTermMap(termMap, writeTermMapOnComplete);
    		  if (reportNotNull) report.addLine("Written term map to file: "+writeTermMapOnComplete);
    	  } catch ( FileNotFoundException e ) {    		  
    	  } // end try-catch FileNotFoundException
      } // end if ( writeTermMapOnComplete!=null )
      return ans;
  } // end sgClosePowerParallel
  
  /**
   * Should be called msToString, as it converts milliseconds into a human-readable string
   */
  public static String nsToString(double ns) {
	  final long totSecs = Math.round(ns/1000);
	  final long secs = totSecs%60;
	  final long totMins = totSecs/60;
	  final long mins = totMins%60;
	  final long hrs = totMins/60;
	  String secString = secs<10 ? "0"+Long.toString(secs) : Long.toString(secs);
	  if ( hrs==0 ) {
		  if ( mins==0 ) return secString;
		  return Long.toString(mins) + ":" + secString;
	  } // end if ( hrs==0 )
	  String minString = mins<10 ? "0"+Long.toString(mins) : Long.toString(mins);
	  return Long.toString(hrs) + ":" + minString + ":" + secString;
  } // end nsToString(double)
  
  public long countFuncApplications(int size0, int size1) {
    BigInteger ans = BigInteger.ZERO;
    final BigInteger s0 = BigInteger.valueOf(size0);
    final BigInteger s1 = BigInteger.valueOf(size1);
    for (Operation op : algebra.operations()) {
      final int r = op.arity();
      ans = ans.add(s1.pow(r).subtract(s0.pow(r)));
    }
    if (ans.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) return -1;
    return ans.longValue() * algebra.getNumberOfFactors();
  }
  
  /**
   * Note this assumes termMap is not null !!!!!!!!
   * 
   * @param map
   * @param indexInCPUs
   * @param numOfOps
   * @param closedMark
   * @param currentMark
   * @param reportNotNull
   * @param rawList
   * @param timing
   */
  public void doOneStagePartialClosure(final ConcurrentHashMap<IntArray,Term> map, 
                                       final int indexInCPUs,
                                       final int numOfOps, 
                                       final int closedMark, final int currentMark,
                                       final boolean reportNotNull,
                                       final List<int[]> rawList,
                                       final CloserTiming timing
                                       ) {
    for (int i = 0; i < numOfOps; i++) {
      //for (Iterator<Operation> it = algebra.operations().iterator(); it.hasNext(); ) {
      //Operation f = it.next();
      Operation f = algebra.operations().get(i);
      final int arity = f.arity();
      if (arity == 0) continue;  // worry about constansts later
      int[] argIndeces = new int[arity];
      for (int j = 0; j < arity - 1; j++) {
        argIndeces[j] = 0;
      }
      argIndeces[arity - 1] = closedMark;
      ArrayIncrementor inc =
        SequenceGenerator.sequenceIncrementor(
            argIndeces, currentMark - 1, closedMark, nCPUs);
      for (int j = 1; j < indexInCPUs; j++) {
        if (!inc.increment()) continue;
      }

      final int[][] arg = new int[arity][];
      while (true) {
        if (Thread.currentThread().isInterrupted()) {
          if (reportNotNull) {
            report.addEndingLine("cancelled ...");
            report.setSize(ans.size());
          }
          return;
        }
        for (int j = 0; j < arity; j++) {
          arg[j] = rawList.get(argIndeces[j]);
        }

        int[] vRaw = f.valueAt(arg);
        //int[] test = f.valueAt(arg);
        IntArray v = new IntArray(vRaw);
        //IntArray testV = new IntArray(test);

        //System.out.println("vRaw == test is " + v.equals(new IntArray(test)));
        if (reportNotNull) timing.incrementApps();
        //appsSoFar = appsSoFar + numberProjs;
        if (!termMap.containsKey(v) && !map.containsKey(v)) {
          List<Term> children = new ArrayList<Term>(arity);
          for (int j = 0; j < arity; j++) {
            //children.set(i, termMap.get(arg.get(i)));
            children.add(termMap.get(ans.get(argIndeces[j])));
          }
          Term term = new NonVariableTerm(f.symbol(), children);
          
          Term old = map.putIfAbsent(v, term);  // make sure it is still not there
          //System.out.println("v: " + v + ", term: " + term + ", old term:" + old + ", thread: " + indexInCPUs);
          System.out.println("v: " + v  + ", old term:" + old + ", thread: " + indexInCPUs);
        }
        if (reportNotNull) timing.incrementNextPassSize();
        if (reportNotNull) report.setSize(ans.size() + map.size());
        if (Thread.currentThread().isInterrupted()) return;

        if (!inc.increment()) break;
      }
    }
  }

 
  
  public boolean isSuppressOutput() {
    return suppressOutput;
  }

  /**
   * Setting this to true will suppress the output about
   * the pass. Useful when calling closing on many small
   * cases.
   * 
   * @param suppressOutput
   */
  public void setSuppressOutput(boolean suppressOutput) {
    this.suppressOutput = suppressOutput;
  }



  class ParallelWorker implements Runnable {
    
    CountDownLatch latch;
    int indexInCPUs;
    ConcurrentHashMap<IntArray,Term> map;
    final int numOfOps;
    final int closedMark; 
    final int currentMark;
    final boolean reportNotNull;
    final List<int[]> rawList;
    final CloserTiming timing;
    
    public ParallelWorker(CountDownLatch latch, int indexInCPUs, 
                          ConcurrentHashMap<IntArray,Term> map,
                          int numOfOps, int closedMark, int currentMark, boolean reportNotNull,
                          final List<int[]> rawList,
                          final CloserTiming timing) {
      this.latch =  latch;
      this.indexInCPUs = indexInCPUs;
      this.map = map;
      this.numOfOps = numOfOps;
      this.closedMark = closedMark;
      this.currentMark = currentMark;
      this.rawList = rawList;
      this.timing = timing;
      this.reportNotNull = reportNotNull;
    }
    
    public void run() {
      doOneStagePartialClosure(map, indexInCPUs, numOfOps, closedMark, currentMark, reportNotNull, rawList, timing);
      latch.countDown();
    }
    
  }
  
  /**
   * One chunk of data from <code>sgClosePowerParallel</code> to be sent to a worker thread
   * @author Jonah Horowitz
   *
   */
/*  static class SGClosePowerChunk {
	  public int opIndex;
	  public int[] initialSegment;
	  
	  public SGClosePowerChunk(int newOpIndex, int[] newInitialSegment) {
		  opIndex=newOpIndex;
		  initialSegment=newInitialSegment;
	  } // end constructor(int, int[])
	  
	  @Override
	  public String toString() {
		  String ans = opIndex+";";
		  for ( int i = 0; i < initialSegment.length; i++ ) {
			  ans+=initialSegment[i]+",";
		  } // end for 0 <= i < initialSegment.length
		  return ans;
	  } // end toString()
  } // end class SGClosePowerChunk/**/
  
}


























